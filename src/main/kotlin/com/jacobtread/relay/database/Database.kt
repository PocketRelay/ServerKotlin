package com.jacobtread.relay.database

import com.jacobtread.relay.database.tables.GalaxyAtWarTable
import com.jacobtread.relay.database.tables.PlayerCharactersTable
import com.jacobtread.relay.database.tables.PlayerClassesTable
import com.jacobtread.relay.database.tables.PlayersTable
import com.jacobtread.relay.utils.Future
import com.jacobtread.relay.utils.VoidFuture
import org.intellij.lang.annotations.Language
import java.sql.Connection
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.Statement
import java.util.concurrent.Executors
import java.util.regex.Pattern
import kotlin.jvm.Throws

/**
 * Central class for database connection and querying logic.
 * Functions on this object should not be called until [init]
 * is called in [com.jacobtread.relay.Environment]
 */
object Database {

    /**
     * The connection to the SQL database
     */
    private lateinit var connection: Connection

    /**
     * Single threaded executor for executing SQL queries on
     * the [connection]
     */
    private var executor = Executors.newSingleThreadExecutor()

    /**
     * Initializes the database setting the [connection] and
     * creating the tables on the database.
     *
     * @param connection The database connection
     * @param sqlite whether to transform the creation queries for SQLite
     */
    @Throws(SQLException::class)
    internal fun init(connection: Connection, sqlite: Boolean) {
        Database.connection = connection
        val statement = connection.createStatement()
        statement.use {
            val tables = listOf(PlayersTable, PlayerClassesTable, PlayerCharactersTable, GalaxyAtWarTable)
            /**
             * SQLite can execute multiple create table querys in a single
             * update, so they are combined and then transformed for SQLite
             * using [transformTableSQLite]
             */
            if (sqlite) {
                val queryBuilder = StringBuilder()
                tables.forEach { queryBuilder.append(it.sql()) }
                val query = transformTableSQLite(queryBuilder.toString())
                statement.executeUpdate(query)
            } else {
                tables.forEach { statement.executeUpdate(it.sql()) }
            }
        }
    }

    /**
     * Executes a task on the [executor] while catching any
     * [SQLException] that get thrown in the process of doing
     * so and returns a future to monitor the progress
     *
     * @param T The future return type
     * @param action The action to execute
     * @return The future result
     */
    private inline fun <T> executeCatching(crossinline action: (Future<T>) -> Unit): Future<T> {
        val future = Future<T>()
        executor.execute {
            try {
                action(future)
            } catch (e: SQLException) {
                future.completeExceptionally(e)
            }
        }
        return future
    }


    /**
     * Executes a SQL query on the connection returning
     * a future of the result set.
     *
     * @param query The SQL query
     * @param setup The optional setup function for the prepared statement
     * @return The future result
     */
    fun query(
        @Language("MySQL") query: String,
        setup: StatementSetup? = null,
    ): Future<ResultSet> {
        return executeCatching { future ->
            val statement = connection.prepareStatement(query)
            statement.use {
                if (setup != null) {
                    setup(statement)
                }
                val resultSet = statement.executeQuery()
                future.complete(resultSet)
            }
        }
    }

    /**
     * Executes an SQL query which returns a boolean future
     * which is the value of whether a data in the database
     * exists and matches the provided query
     *
     * @param query The SQL query
     * @param setup The optional setup function for the prepared statement
     * @return The future result
     */
    fun exists(
        @Language("MySQL") query: String,
        setup: StatementSetup? = null,
    ): Future<Boolean> {
        return query(query, setup)
            .thenApply { it.next() }
    }

    /**
     * Executes an SQL update that returns a [ResultSet] containing
     * keys that were generated by the database
     *
     * @param query The SQL query
     * @param setup The optional setup function for the prepared statement
     * @return The future result
     */
    fun updateWithKeys(
        @Language("MySQL") query: String,
        setup: StatementSetup,
    ): Future<ResultSet> {
        return executeCatching { future ->
            val statement = connection.prepareStatement(query, Statement.RETURN_GENERATED_KEYS)
            statement.use {
                setup(statement)
                statement.executeUpdate()
                future.complete(statement.generatedKeys)
            }
        }
    }

    /**
     * Executes an SQL update
     *
     * @param query The SQL query
     * @param setup The optional setup function for the prepared statement
     * @return The future result
     */
    fun update(
        @Language("MySQL") query: String,
        setup: StatementSetup,
    ): VoidFuture {
        return executeCatching { future ->
            val statement = connection.prepareStatement(query)
            statement.use {
                setup(statement)
                statement.executeUpdate()
                future.complete(null)
            }
        }
    }

    /**
     * Transform the specified SQL create table query for
     * use in SQLite which is as simple as removing all the
     * lengths from the models types and transforming them
     * to their SQLite form and removing the underscore
     * from AUTO_INCREMENT
     *
     *  - BIGING, INT, BOOLEAN -> INTEGER
     *  - FLOAT -> REAL
     *  - VARCHAR -> TEXT
     *
     * @param query The query to transform
     * @return The transformed query
     */
    private fun transformTableSQLite(query: String): String {
        val regex = Pattern.compile("(BIGINT|INT|BOOLEAN|VARCHAR|FLOAT)(\\(\\d+\\))?")
        val matcher = regex.matcher(query)

        var newQuery = matcher.replaceAll {
            when (val type = it.group(1)) {
                "BIGINT", "INT", "BOOLEAN" -> "INTEGER"
                "FLOAT" -> "REAL"
                "VARCHAR" -> "TEXT"
                else -> type
            }
        }

        newQuery = newQuery.replace("AUTO_INCREMENT", "AUTOINCREMENT")
        return newQuery
    }
}